#include <include/assert.h>
#include <include/error.h>
#include <include/lib.h>
#include <include/mmu.h>
#include <include/string.h>

#include <kernel/kclock.h>
#include <kernel/pmap.h>

// These variables are set by i386_detect_memory()
size_t npages;                // Amount of physical memory (in pages)
static size_t npages_basemem; // Amount of base memory (in pages)

// These variables are set in mem_init()
pde_t *kern_pgdir;                      // Kernel's initial page directory
struct PageInfo *pages;                 // Physical page state array
static struct PageInfo *page_free_list; // Free list of physical pages

// --------------------------------------------------------------
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int nvram_read(int r) { return mc146818_read(r) | (mc146818_read(r + 1) << 8); }

static void i386_detect_memory(void) {
  size_t basemem, extmem, ext16mem, totalmem;

  // Use CMOS calls to measure available base & extended memory.
  // (CMOS calls return results in kilobytes.)
  basemem = nvram_read(NVRAM_BASELO);
  extmem = nvram_read(NVRAM_EXTLO);
  ext16mem = nvram_read(NVRAM_EXT16LO) * 64;

  // Calculate the number of physical pages available in both base
  // and extended memory.
  if (ext16mem) {
    totalmem = 16 * 1024 + ext16mem;
  } else if (extmem) {
    totalmem = 1 * 1024 + extmem;
  } else {
    totalmem = basemem;
  }

  npages = totalmem / (PGSIZE / 1024);
  npages_basemem = basemem / (PGSIZE / 1024);

  printf("Physical memory: %dK available, base = %dK, extended = %dK\n", totalmem, basemem, totalmem - basemem);
}

// --------------------------------------------------------------
// Set up memory mappings above UTOP.
// --------------------------------------------------------------

static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm);
static void check_page_free_list(bool only_low_memory);
static void check_page_alloc(void);
static void check_kern_pgdir(void);
static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
static void check_page(void);
static void check_page_installed_pgdir(void);

// This simple physical memory allocator is used only while JOS is setting
// up its virtual memory system.  page_alloc() is the real allocator.
//
// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
//
// If n==0, returns the address of the next free page without allocating
// anything.
//
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *boot_alloc(uint32_t n) {
  static char *nextfree; // virtual address of next byte of free memory
  char *result;

  // Initialize nextfree if this is the first time.
  // 'end' is a magic symbol automatically generated by the linker,
  // which points to the end of the kernel's bss segment:
  // the first virtual address that the linker did *not* assign
  // to any kernel code or global variables.
  if (!nextfree) {
    extern char end[];
    nextfree = ROUNDUP((char *)end, PGSIZE);
  }

  // Allocate a chunk large enough to hold 'n' bytes, then update
  // nextfree.  Make sure nextfree is kept aligned
  // to a multiple of PGSIZE.
  //
  // LAB 2: Your code here.
  result = nextfree;
  if (n > 0) {
    nextfree += ROUNDUP(n, PGSIZE);
  }

  return result;
}

void mem_init() {
  uint32_t cr0;
  size_t n;

  // Find out how much memory the machine has (npages & npages_basemem).
  i386_detect_memory();

  //////////////////////////////////////////////////////////////////////
  // create initial page directory.
  kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
  memset(kern_pgdir, 0, PGSIZE);

  //////////////////////////////////////////////////////////////////////
  // Recursively insert PD in itself as a page table, to form
  // a virtual page table at virtual address UVPT.
  // (For now, you don't have understand the greater purpose of the
  // following line.)

  // Permissions: kernel R, user R
  kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

  //////////////////////////////////////////////////////////////////////
  // Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
  // The kernel uses this array to keep track of physical pages: for
  // each physical page, there is a corresponding struct PageInfo in this
  // array.  'npages' is the number of physical pages in memory.  Use memset
  // to initialize all fields of each struct PageInfo to 0.
  // Your code goes here:
  pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
  memset(pages, 0, npages * sizeof(struct PageInfo));

  //////////////////////////////////////////////////////////////////////
  // Now that we've allocated the initial kernel data structures, we set
  // up the list of free physical pages. Once we've done so, all further
  // memory management will go through the page_* functions. In
  // particular, we can now map memory using boot_map_region
  // or page_insert
  page_init();

  check_page_free_list(1);
  printf("check_page_free_list OK");
}

// --------------------------------------------------------------
// Checking functions.
// --------------------------------------------------------------

//
// Check that the pages on the page_free_list are reasonable.
//
static void check_page_free_list(bool only_low_memory) {
  struct PageInfo *pp;
  unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES; /* NPDENTRIES = 1024 */
  int nfree_basemem = 0, nfree_extmem = 0;
  char *first_free_page;

  if (!page_free_list)
    panic("'page_free_list' is a null pointer!");

  if (only_low_memory) {
    // Move pages with lower addresses first in the free
    // list, since entry_pgdir does not map all pages.
    struct PageInfo *pp1, *pp2;
    struct PageInfo **tp[2] = {&pp1, &pp2};
    for (pp = page_free_list; pp; pp = pp->pp_link) {
      // page2pa(pp): (pp - pages) << PGSHIFT /* 得到 pp 这个 PageInfo 所描述的页的物理地址 */
      // PDX(la): (la >> PDXSHIFT) & 0x3FF /* 得到线性地址 la 的页目录索引, 也就是 la 的高 10 bits */
      // PDX(page2pa(pp)): 得到 pp 描述的页的物理地址的“页目录索引”, 即高 10 bits */
      int pagetype = PDX(page2pa(pp)) >= pdx_limit; /* only_low_memory == true 时 pdx_limit = 1 */
      // pagetype 是一个布尔值, 只能等于0或1.
      // 页目录一共有 1024 项, 每一项指向一个页表, 每个页表能映射 4MB 虚拟内存, 1024 个页表共能映射 4GB 虚拟内存.
      // 1024 个页表对应的页目录索引为 { 0, 1, 2, ... , 1023 }. 如果 PDX(page2pa(pp)) == 0, 就说明 pp 描述的
      // 物理页地址属于 [0, 4MB) 这个范围, 那么 pagetype = 0; 如果 pp 描述的物理页地址在 4MB 之上, pagetype = 1.
      *tp[pagetype] = pp;
      tp[pagetype] = &pp->pp_link;
      // 由于 page_free_list 的方向是由高地址页指向低地址页, 所以 for 循环结束后 *tp[0] 也就是 pp1 指向的
      // PageInfo 所描述的物理页地址为0
    }
    *tp[1] = 0;
    *tp[0] = pp2;
    page_free_list = pp1;
  }

  // if there's a page that shouldn't be on the free list,
  // try to make sure it eventually causes trouble.
  for (pp = page_free_list; pp; pp = pp->pp_link)
    if (PDX(page2pa(pp)) < pdx_limit)
      memset(page2kva(pp), 0x97, 128);

  first_free_page = (char *)boot_alloc(0);
  for (pp = page_free_list; pp; pp = pp->pp_link) {
    // check that we didn't corrupt the free list itself
    assert(pp >= pages);
    assert(pp < pages + npages);
    assert(((char *)pp - (char *)pages) % sizeof(*pp) == 0);

    // check a few pages that shouldn't be on the free list
    assert(page2pa(pp) != 0);
    assert(page2pa(pp) != IOPHYSMEM);
    assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
    assert(page2pa(pp) != EXTPHYSMEM);
    assert(page2pa(pp) < EXTPHYSMEM || (char *)page2kva(pp) >= first_free_page);

    if (page2pa(pp) < EXTPHYSMEM)
      ++nfree_basemem;
    else
      ++nfree_extmem;
  }

  assert(nfree_basemem > 0);
  assert(nfree_extmem > 0);

  printf("check_page_free_list() succeeded!\n");
}
// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------

//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void page_init(void) {
  // The example code here marks all physical pages as free.
  // However this is not truly the case.  What memory is free?
  //  1) Mark physical page 0 as in use.
  //     This way we preserve the real-mode IDT and BIOS structures
  //     in case we ever need them.  (Currently we don't, but...)
  //  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
  //     is free.
  //  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
  //     never be allocated.
  //  4) Then extended memory [EXTPHYSMEM, ...).
  //     Some of it is in use, some is free. Where is the kernel
  //     in physical memory?  Which pages are already in use for
  //     page tables and other data structures?
  //
  // Change the code to reflect this.
  // NB: DO NOT actually touch the physical memory corresponding to
  // free pages!
  // size_t i;
  // for (i = 0; i < npages; i++) {
  // 	pages[i].pp_ref = 0;
  // 	pages[i].pp_link = page_free_list;
  // 	page_free_list = &pages[i];
  // }

  size_t i;
  extern char _start[], end[];
  extern pde_t entry_pgdir[];
  extern pte_t entry_pgtable[];
  physaddr_t addr, kern_start, kern_end, pgdir_addr, pgtable_addr;

  kern_start = (physaddr_t) ROUNDDOWN((char *)_start, PGSIZE) - KERNBASE;
  kern_end = (physaddr_t) ROUNDDOWN((char *)end, PGSIZE) - KERNBASE;
  pgdir_addr = (physaddr_t) entry_pgdir - KERNBASE;
  pgtable_addr = (physaddr_t) entry_pgtable - KERNBASE;

  printf("kern_entry: %x  kern_end: %x\n", kern_start, kern_end);
  printf("pgdir_addr: %x  pgtable_addr: %x\n", pgdir_addr, pgtable_addr);
  printf("npages: %d  npages_basemem: %d\n", npages, npages_basemem);

  for (i = 0, addr = 0; i < npages; i++, addr += PGSIZE) {
    pages[i].pp_ref = 0;

    if (addr >= PGSIZE && addr < npages_basemem * PGSIZE) {
      pages[i].pp_ref = 1;
    } else if (addr >= IOPHYSMEM && addr < EXTPHYSMEM) {
      pages[i].pp_ref = 1;
    } else if (addr >= EXTPHYSMEM) {
      if (addr >= kern_start && addr <= kern_end) { /* kernel */
        pages[i].pp_ref = 1;
      } else if (addr == (physaddr_t) entry_pgdir || addr == (physaddr_t) entry_pgtable) { /* pgdir & pgtable */
        pages[i].pp_ref = 1;
      }
    }

    pages[i].pp_link = page_free_list;
    page_free_list = &pages[i];
  }

  printf("page_free_list: %x\n", page_free_list);
}